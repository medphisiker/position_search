# Поиск позиции

Это задача с VK All Cups ([ссылка](https://cups.online/ru/workareas/education_2277/1230/2390/)).

Дан отсортированный по возрастанию массив целых чисел и заданное число:
- если заданное число уже находится в массиве, верните его индекс.
- если числа в массиве нет, верните индекс, где оно должно находиться, чтобы сохранить порядок сортировки.

## Формат входных данных

- В первой строке задаётся число N — количество элементов в массиве.
- Во второй строке вводится массив из N целых чисел, разделённых пробелами.
- В третьей строке задаётся число `target`, для которого нужно найти индекс.

## Формат выходных данных

Программа должна вывести одно число — индекс числа `target`, если оно уже есть в массиве, или индекс, где оно должно находиться для сохранения порядка сортировки.

## Пример 1

### Входные данные

```
5
5 7 9 11 13
6
```

### Выходные данные

```
1
```

### Пояснение

Если бы в массиве было число 6, то оно находилось бы под индексом 1, то есть правее 5 и левее 7.

# Решения и подходы

## 1. Ручная реализация бинарного поиска

### Основной подход
Самый эффективный способ решения задачи - бинарный поиск с временной сложностью O(log n) и пространственной сложностью O(1).

### Ключевые особенности реализации:

#### 1.1 Обработка граничных случаев
```python
# обработка пустого массива
if not array:
    return 0

# оптимизация для значений лежащих вне диапазона массива
if target <= array[0]:
    return 0
if target > array[-1]:
    return len(array)
```

#### 1.2 Стандартный алгоритм бинарного поиска
```python
left, right = 0, len(array) - 1

while left <= right:
    mid = left + (right - left) // 2
    
    if array[mid] == target:
        return mid
    elif array[mid] < target:
        left = mid + 1
    else:
        right = mid - 1

# если элемент не найден, left указывает на позицию для вставки
return left
```

#### 1.3 Важные нюансы:
- **Формула вычисления середины**: `left + (right - left) // 2` вместо `(left + right) // 2` для предотвращения переполнения
- **Условие цикла**: `left <= right` для обработки всех случаев, включая одномерные массивы
- **Возврат значения**: `left` всегда указывает на правильную позицию для вставки, если элемент не найден

### Сравнение реализаций:

#### `solution_submit.py` - версия для публикации решения на платформе VK All Cups
- Оптимизирована для скорости
- Содержит проверки граничных случаев
- Не содержит отладочной информации
- Идеальна для сдачи в тестовую систему

#### `solution_debug.py` - версия для себя с элементами визуализации
- Содержит функцию визуализации работы алгоритма
- Помогает понять, как работает бинарный поиск
- Полезна для обучения и отладки
- Имеет те же алгоритмические характеристики, но с дополнительным выводом

## 2. Использование встроенных функций

### Простое решение с использованием `bisect.bisect_left`

#### Сигнатура функции:
```python
bisect.bisect_left(a, x, lo=0, hi=len(a), *, key=None)
```

#### Параметры:
- `a`: Отсортированный список для поиска
- `x`: Значение, которое нужно найти
- `lo`: (Опционально) Нижняя граница диапазона поиска (по умолчанию 0)
- `hi`: (Опционально) Верхняя граница диапазона поиска (по умолчанию len(a))
- `key`: (Опционально) Функция для преобразования элементов перед сравнением (добавлена в Python 3.10)

#### Возвращаемое значение:
Возвращает точку вставки `ip` такую, что все элементы в `a[lo:ip]` меньше `x`, а все элементы в `a[ip:hi]` больше или равны `x`.

#### Примеры использования:

##### Базовый пример:
```python
import bisect

array = [5, 7, 9, 11, 13]
target = 6

# Возвращает 1, так как 6 должна быть вставлена между 5 и 7
result = bisect.bisect_left(array, target)
print(result)  # 1
```

#### Преимущества:
- **Краткость и читаемость**: Всего одна строка кода
- **Оптимизированная реализация**: Написана на C, высокая производительность
- **Надежность и проверенность временем**: Часть стандартной библиотеки Python
- **Гибкость**: Поддержка диапазонов поиска и ключевых функций
- **Обработка граничных случаев**: Корректно работает с пустыми массивами

#### Производительность:
- **Временная сложность**: O(log n) - такая же, как у ручной реализации
- **Пространственная сложность**: O(1) - не требует дополнительной памяти
- **Фактическая скорость**: Быстрее ручной реализации за счет C-оптимизации

#### Когда использовать:
- **В продакшн-коде**: Всегда, когда нужна максимальная производительность
- **В учебных проектах**: Хорошо для быстрого прототипирования
- **На собеседованиях**: Можно упомянуть как оптимальное решение, но показать и ручную реализацию

## 3. Тестирование

### Структура тестов
Тесты организованы в логические группы для покрытия всех возможных сценариев:

#### 3.1 Тесты на вставку в начало
- Вставка перед первым элементом
- Вставка в начало (первый элемент существует)

#### 3.2 Тесты на вставку в середину
- Вставка между любыми двумя элементами
- Проверка для нечетных и четных массивов

#### 3.3 Тесты на вставку в конец
- Вставка после последнего элемента
- Вставка в конец (последний элемент существует)

#### 3.4 Тесты на поиск существующих элементов
- Поиск первого, последнего и среднего элементов
- Проверка всех позиций в массиве

#### 3.5 Тесты для граничных случаев
- Массивы из 2 элементов
- Массивы из 1 элемента
- Пустые массивы

### Функция для тестирования
Функция `run_single_test` обеспечивает:
- Структурированный вывод информации о тесте
- Автоматическую проверку результатов
- Информативные сообщения об ошибках

## 4. Сложность алгоритма

### Временная сложность: O(log n)
- `Бинарный поиск` делит массив пополам на каждой итерации
- Количество итераций растет логарифмически с размером массива
- Оптимально для отсортированных массивов

### Пространственная сложность: O(1)
- Используется только фиксированное количество переменных
- Не требует дополнительной памяти, зависящей от размера входных данных